#!/bin/bash
# Common shell script library
# Author: jdum
# Date: 30 avril 2019
# Version 1.1
# Add _mdbg

# hash array of supported colors
declare -A COLORS=( ["black"]="30" ["red"]="31" ["green"]="32" ["brown_orange"]="33"\
                    ["blue"]="34" ["purple"]="35"  ["cyan"]="36" ["light_gray"]="37")


#--------------------------------------------------------------------------------------------------------------
# Name        : _getDateLine
# Parameters  :
# Description : returns formated date string for application message, e.g [YYYmm][hhss]
# Returns     :
_getDateLine()
{
	echo -ne "[$(date +"%m-%d-%Y")][$(date +"%T")]"
}
#--------------------------------------------------------------------------------------------------------------
# Name        : _colorString
# parameters  : first parameter the color name, second the message to be colored
# Description : Returns a colored string
# Returns     : true
#
_colorString()
{
	color="$1"
	string="$2"
	escColorValue=${COLORS["$color"]}
	# escape sequence
	escStart="\033["
	escEnd="\033[0m"
	# char formating
	bold=';1'
	underlined=4
	flashing=1
	echo -ne "${escStart}${escColorValue};${escColorValue}${bold}m${string}${escEnd}"
  return 0
}
#--------------------------------------------------------------------------------------------------------------
# Name        : _displayColorTag
# Parameters  :
# Description : Display tags with different color for tags like OK, NOK ,INFO
# Returns     :
#
_displayColorTag()
{
	   logfile="/tmp/$(basename ${0}).log"
     tag="${1}"
     text="${2}"

     case ${tag} in

         NOK)   echo -ne "$(_getDateLine)[$(_colorString 'red' $tag)]  ${text}" | tee --append $logfile
         ;;
         OK)    echo -ne "$(_getDateLine)[$(_colorString 'green' $tag)]  ${text}" | tee --append $logfile
         ;;
         INFO)  if [ $VERBOSE -eq 1 ]
                then
                     if [ _isInArray VALID_LEVELS ${DEBUG} ]
                     then
                       echo -ne "$(_getDateLine)[$(_colorString 'brown_orange' $tag)]  ${text}" | tee --append $logfile
                     fi
                fi
	   esac
     return 0
}
#--------------------------------------------------------------------------------------------------------------
# Name        : _getTimeStamp
# Parameters  :
# Description : return a time stamp of the form YYYmmddHHMMSS
# Returns     : true
#
_getTimeStamp()
{
 echo -ne $(date +"%Y%m%d%H%M%S")
 return 0
}
#--------------------------------------------------------------------------------------------------------------
# Name        : _mok
# Parameters  : the message
# Description : display OK messages
# Returns     :
#
_mok()
{
	{ _displayColorTag OK  "${1}";echo; }
  return 0
}
#--------------------------------------------------------------------------------------------------------------
# Name        : _mnok
# Parameters  : the message
# Description : display error messages
# Returns     : error 4
#
_mnok()
{
	{ _displayColorTag NOK  "${1}"; echo; return 4;}
  return 0
}
#--------------------------------------------------------------------------------------------------------------
# Name        : _minf
# Parameters  : the message, is active if gtrac -v
# Description : display info messages
# Returns     :
#
_minf()
{
	{ _displayColorTag INFO  "${1}";echo;}
  return 0
}
#--------------------------------------------------------------------------------------------------------------
# Name        : _mdbg
# Parameters  : the level of debug, the debug message
# Description : format debug messages, with colored DEBUG tagged based upon debug level
# Returns     : true, exit if invalid debug level
#
_mdbg()
{
	msgDebugLevel=$1
	message="$2"
  thisTag='DEBUG'

  if [ ${msgDebugLevel} -le ${DEBUG} ]
  then
  # color selectION  based upon the debug level pass to _mdbg
     case $msgDebugLevel in
       1) color="blue"
			 ;;
       2|3|4|5|6) color="purple"
       ;;
			21)  color="brown_orange"
			 ;;
	    esac
      { coloredTag=$(_colorString $color "$thisTag");echo -ne "$(_getDateLine)["$coloredTag"]  ${message}" | tee --append $logfile ;echo;}

		  return 0
	fi
}
#--------------------------------------------------------------------------------------------------------------
# Name        : _setLogging
# Parameters  :
# Description : Initialize the application logfile
# Returns     : true
#
_setLogging()
{
	_mdbg 2 "-- Enter _setLogging"
  logfile=/tmp/$(basename ${0}).log
  timestamp=$(_getTimeStamp)
  [ -f ${logfile} ] && mv ${logfile} "${logfile}.$(_getTimeStamp)" && _minf "logfile ${logfile} is backuped in ${logfile}.$timestamp"
  echo "# $(_getDateLine) $(basename $0) logging started"> ${logfile}
	_mdbg 2 "-- Leave _setLogging"
  return 0
}
#--------------------------------------------------------------------------------------------------------------
# Name        : _upperCase
# Parameters  : the string to be in uppercase
# Description : format a string in upper case
# Returns     : true
#
_upperCase()
{
  echo ${1}|dd conv=ucase 2>/dev/null && return 0
}
#--------------------------------------------------------------------------------------------------------------
# Name        : _isInArray
# Parameters  : The array name's as a string, the element to e found in the array
# Description : test if an element belongs to an array
# Return      : true if successfull
#
_isInArray () {
    local array="$1[@]"
    local seeking=$2
    local in=1
    for element in "${!array}"; do
        if [[ $element == $seeking ]]; then
            in=0
            break
        fi
    done
    return $in
}

#_isInArray arr "a b"  && echo yes || echo no    # no
#_isInArray arr "d e"  && echo yes || echo no    # yes
